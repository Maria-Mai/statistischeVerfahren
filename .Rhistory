library(raster)
plot_board <- function(board)
plot(
raster(as.matrix(board)),
legend = FALSE,
col = c("white", "blue"),
xaxt = 'n',
yaxt = 'n'
)
row_sums<-function(m){
rows<- sapply(1:ncol(m),function(x) sum(m[x,]))
rows
}
col_sums<-function(m){
cols<- sapply(1:ncol(m), function(x) sum(m[,x]))
cols
}
get_margins<-function(m){
filled_cols<- which(col_sums(m)!=0)
filled_rows<- which(row_sums(m)!=0)
fsize=nrow(m)
margins<-c(filled_cols[1]-1,fsize-filled_cols[length(filled_cols)], filled_rows[1]-1, fsize-filled_rows[length(filled_rows)])
margins
}
get_threshold<-function(field){
fsize<-nrow(field)
if (fsize>=30){
threshold<-round(fsize*0.4)
}else{
threshold<-6
}
threshold
}
check_size_too_big<-function(field){
margins<-get_margins(field)
threshold<-get_threshold(field)
downsize<-sapply(1:4, function(index){
ifelse(margins[index]>=threshold, margins[index]<-TRUE, margins[index]<-FALSE)
})
ifelse ((downsize[1] || downsize[2]) && (downsize[3] || downsize[4]), TRUE, FALSE)
}
cut_margins<- function(m){
margins<-get_margins(m)
fsize<-nrow(m)
margins<-Matrix(rbind(margins[1:2],margins[3:4]))
tmp<-sapply(1:2, function(index){which.max(margins[index,])})
tmpii<-sapply(1:2, function(index){margins[index,tmp[index]]})
reduce<-tmpii[which.min(tmpii)]-2
for (i in 1:2){
if(i%%2==0){
if(tmp[i]%%2==0){
m<-m[,1:(fsize-reduce)]
}
else{
m<-m[,reduce:fsize]
}
}
else{
if(tmp[i]%%2==0){
m<-m[1:(fsize-reduce),]}
else{m<-m[reduce:fsize,]}}}
m
}
check_size_to_small <- function(m){
penultimate <- ncol(m)-1 # m should always be quadratic
sum_margin <- sum(m[,2]) + sum(m[2,]) +  sum(m[penultimate,]) +  sum(m[,penultimate]) -
m[2,2] - m[2,penultimate] - m[penultimate,2] - m[penultimate, penultimate] # remove corners
return(sum_margin > 0)
}
enlarg_matrix <- function(m){
new_empty_row_matrix <- Matrix(0,ncol=ncol(m), nrow=nrow(m), sparse = TRUE)
new_empty_col_matrix <- Matrix(0,ncol=ncol(m), nrow=3*nrow(m), sparse = TRUE)
tmp <- rbind(new_empty_row_matrix,rbind(m,new_empty_row_matrix))
tmp <- cbind(new_empty_col_matrix, cbind(tmp, new_empty_col_matrix))
return(tmp)
}
get_neighbor_indices <- function(ind, ncol){
c(ind-(ncol+1), ind-(ncol), ind-(ncol-1), ind-1, ind+1, ind+(ncol-1), ind+ncol, ind+ncol+1 )
}
add_neighbors = function(indices,ncol) c(indices ,as.vector(sapply(indices, get_neighbor_indices,ncol=ncol)))
gol_ruleset_maker <- function(survive,revive)
function(sums, living){
vector(mode='numeric',length = length(sums)) -> new_states
sums[living] -> living_sum
sums[!living] -> dead_sum
ifelse(living_sum %in% survive,TRUE,FALSE) -> living_new_state
ifelse(dead_sum %in% revive,TRUE,FALSE) -> dead_new_state
living_new_state -> new_states[living]
dead_new_state -> new_states[!living]
new_states
}
normal_gol_rulset = gol_ruleset_maker(
survive=c(2,3),
revive=c(3))
iterate_board = function(
board,
ruleset){
which(board == 1) -> initial_living_indices
unique(add_neighbors(initial_living_indices,ncol = ncol(board))) -> candidates
sapply(1:length(candidates),function(index){
n = get_neighbor_indices(candidates[index],ncol(board)) -> n
sum(board[n])
}) -> board_sums
ruleset(
board_sums,
candidates %in% initial_living_indices
) -> new_values
Matrix(0,nrow = nrow(board),ncol=ncol(board),byrow=TRUE,sparse=TRUE) -> new_board
1 -> new_board[candidates[which(new_values == TRUE)]]
new_board
}
glider <- Matrix(c(
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,1,0,0,0,0,
0,0,0,0,1,0,0,0,
0,0,1,1,1,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0),
nrow = 8, ncol = 8, sparse = TRUE)
gliders <- Matrix(c(
1,1,1,0,0,0,0,0,
1,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,
0,0,0,0,1,0,0,0,
0,0,0,0,0,1,0,0,
0,0,0,1,1,1,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0),
nrow = 8, ncol = 8, sparse = TRUE)
small_spaceship <- Matrix(
c(0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,
0,0,0,1,1,0,0,0,0,
0,0,0,1,1,1,0,0,0,
0,0,1,0,1,1,0,0,0,
0,0,1,1,1,0,0,0,0,
0,0,0,1,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0),
nrow=9, ncol=9, sparse = TRUE)
r_pentominos <- Matrix(
c(0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,
0,0,1,1,0,0,0,0,0,
0,1,1,0,0,0,0,0,0,
0,0,1,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0
),
nrow=9, ncol=9, sparse = TRUE)
random_board <- function(n)
Matrix(sample(0:1,n*n,replace=TRUE),n,n,sparse = TRUE)
glider-> board
100 -> run_n_times
for(i in 1:run_n_times){
if(check_size_to_small(board)) enlarg_matrix(board) -> board #r magic ;-)
if(check_size_too_big(board)) cut_margins(board) -> board
# Plot and sleep
plot_board(board)
Sys.sleep(0.05)
iterate_board(
board=board,
ruleset=normal_gol_rulset
) -> board
}
`-`(1)
c("a", "b", "c")[2]
x <- "dynamically"
outer <- function()x <- "lexically"
inner <- functionprint(x)
}
return(inner)
}
scope <- outer()
scope()
x <- "dynamically"
outer <- function(){
x <- "lexically"
inner <- function(){
print(x)
}
return(inner)
}
scope <- outer()
scope()
x <- 2L
x <- "gg"
x
selectFeatures <- function(m){ #m matrix mit allein einflussgroessen
resultList <- list()
for(i in 1:ncol(m)){ # Spaltenindex
j = 1 # Listenindex für das Ergebnis
difference <- abs(sum((m[i] - m[i+1])) / nrow(m))
if(difference >= 0.001){
resultList[[j]] <- m[,i]
resultList[[j+1]] <- m[,i+1]
j = j+2
i = i+2
}
else{
resultList[[j]] <- m[,j]
j = j+1
i = i+2
}
if (i >= ncol(m)) {
resultList[[j]] <- m[,j]
return(resultList)
}
}
return(resultList)
}
selectFeatures(nir.data[4:])
selectFeatures(nir.data[,4])
nir.data <- read.csv("NIR.csv", sep = ";", header=TRUE)
head(nir.data)
Q
library(leaps)
nir.data <- read.csv("NIR.csv", sep = ";", header=TRUE)
head(nir.data)
#nir.model <- regsubsets(y=nir.data[,2], x=nir.data[,4:ncol(nir.data)], really.big = TRUE)
selectFeatures <- function(m){ #m matrix mit allein einflussgroessen
resultList <- list()
for(i in 1:ncol(m)){ # Spaltenindex
j = 1 # Listenindex für das Ergebnis
difference <- abs(sum((m[i] - m[i+1])) / nrow(m))
if(difference >= 0.001){
resultList[[j]] <- m[,i]
resultList[[j+1]] <- m[,i+1]
j = j+2
i = i+2
}
else{
resultList[[j]] <- m[,j]
j = j+1
i = i+2
}
if (i >= ncol(m)) {
resultList[[j]] <- m[,j]
return(resultList)
}
}
return(resultList)
}
selectFeatures(nir.data[,4:ncol(nir.data)])
library(leaps)
nir.data <- read.csv("NIR.csv", sep = ";", header=TRUE)
head(nir.data)
#nir.model <- regsubsets(y=nir.data[,2], x=nir.data[,4:ncol(nir.data)], really.big = TRUE)
selectFeatures <- function(m){ #m matrix mit allein einflussgroessen
resultList <- list()
for(i in 1:ncol(m)){ # Spaltenindex
j = 1 # Listenindex für das Ergebnis
difference <- abs(sum((m[i] - m[i+1])) / nrow(m))
if(difference >= 0.001){
resultList[[j]] <- m[,i]
resultList[[j+1]] <- m[,i+1]
j = j+2
i = i+2
}
else{
resultList[[j]] <- m[,j]
j = j+1
i = i+2
}
if (i >= ncol(m)) {
resultList[[j]] <- m[,j]
return(resultList)
}
}
return(resultList)
}
selectFeatures(nir.data[,4:ncol(nir.data)])
setwd("/home/mai/Documents/UniSS19/statVerfahrenProjekt/")
library(leaps)
nir.data <- read.csv("NIR.csv", sep = ";", header=TRUE)
head(nir.data)
#nir.model <- regsubsets(y=nir.data[,2], x=nir.data[,4:ncol(nir.data)], really.big = TRUE)
selectFeatures <- function(m){ #m matrix mit allein einflussgroessen
resultList <- list()
for(i in 1:ncol(m)){ # Spaltenindex
j = 1 # Listenindex für das Ergebnis
difference <- abs(sum((m[i] - m[i+1])) / nrow(m))
if(difference >= 0.001){
resultList[[j]] <- m[,i]
resultList[[j+1]] <- m[,i+1]
j = j+2
i = i+2
}
else{
resultList[[j]] <- m[,j]
j = j+1
i = i+2
}
if (i >= ncol(m)) {
resultList[[j]] <- m[,j]
return(resultList)
}
}
return(resultList)
}
selectFeatures(nir.data[,4:ncol(nir.data)])
help <- selectFeatures(nir.data[,4:ncol(nir.data)])
resultMatrix <- do.call(cbind, help)
ncol(resultMatrix)
library(leaps)
nir.data <- read.csv("NIR.csv", sep = ";", header=TRUE)
head(nir.data)
#nir.model <- regsubsets(y=nir.data[,2], x=nir.data[,4:ncol(nir.data)], really.big = TRUE)
selectFeatures <- function(m){ #m matrix mit allein einflussgroessen
resultList <- list()
for(i in 1:ncol(m)){ # Spaltenindex
j = 1 # Listenindex für das Ergebnis
difference <- abs(sum((m[i] - m[i+1])) / nrow(m))
print(difference)
if(difference >= 0.001){
resultList[[j]] <- m[,i]
resultList[[j+1]] <- m[,i+1]
j = j+2
i = i+2
}
else{
resultList[[j]] <- m[,j]
j = j+1
i = i+2
}
if (i >= ncol(m)) {
resultList[[j]] <- m[,j]
return(resultList)
}
}
return(resultList)
}
help <- selectFeatures(nir.data[,4:ncol(nir.data)])
resultMatrix <- do.call(cbind, help)
ncol(resultMatrix)
library(leaps)
nir.data <- read.csv("NIR.csv", sep = ";", header=TRUE)
head(nir.data)
#nir.model <- regsubsets(y=nir.data[,2], x=nir.data[,4:ncol(nir.data)], really.big = TRUE)
selectFeatures <- function(m){ #m matrix mit allein einflussgroessen
resultList <- list()
for(i in 1:ncol(m)){ # Spaltenindex
j = 1 # Listenindex für das Ergebnis
difference <- abs(sum((m[i] - m[i+1])) / nrow(m))
print(difference)
if(difference >= 0.0001){
resultList[[j]] <- m[,i]
resultList[[j+1]] <- m[,i+1]
j = j+2
i = i+2
}
else{
resultList[[j]] <- m[,j]
j = j+1
i = i+2
}
if (i >= ncol(m)) {
resultList[[j]] <- m[,j]
return(resultList)
}
}
return(resultList)
}
help <- selectFeatures(nir.data[,4:ncol(nir.data)])
resultMatrix <- do.call(cbind, help)
ncol(resultMatrix)
i = i+2
source('~/Documents/UniSS19/statVerfahrenProjekt/main.R', echo=TRUE)
list.append
source('~/Documents/UniSS19/statVerfahrenProjekt/main.R', echo=TRUE)
source('~/Documents/UniSS19/statVerfahrenProjekt/main.R', echo=TRUE)
library(leaps)
nir.data <- read.csv("NIR.csv", sep = ";", header=TRUE)
head(nir.data)
#nir.model <- regsubsets(y=nir.data[,2], x=nir.data[,4:ncol(nir.data)], really.big = TRUE)
selectFeatures <- function(m){ #m matrix mit allein einflussgroessen
resultList <- matrix(nrow=nrow(m), ncol=0)
for(i in 1:ncol(m)){ # Spaltenindex
print(i)
difference <- abs(sum((m[i] - m[i+1])) / nrow(m))
print(difference)
if(difference >= 0.001){
resultList <- cbind(resultList, m[,i:i+1])
i = i+2
}
else{
resultList <- cbind(resultList, m[,i])
i = i+2
}
if (i >= ncol(m)) {
resultList <- cbind(resultList, m[,i])
return(resultList)
}
}
return(resultList)
}
help <- selectFeatures(nir.data[,4:ncol(nir.data)])
ncol(help)
library(leaps)
nir.data <- read.csv("NIR.csv", sep = ";", header=TRUE)
head(nir.data)
#nir.model <- regsubsets(y=nir.data[,2], x=nir.data[,4:ncol(nir.data)], really.big = TRUE)
selectFeatures <- function(m){ #m matrix mit allein einflussgroessen
resultList <- matrix(nrow=nrow(m), ncol=0)
for(i in 1:ncol(m),2){ # Spaltenindex
print(i)
difference <- abs(sum((m[i] - m[i+1])) / nrow(m))
print(difference)
if(difference >= 0.001){
resultList <- cbind(resultList, m[,i:i+1])
i <- i+2
}
else{
resultList <- cbind(resultList, m[,i])
i <- i+2
}
if (i >= ncol(m)) {
resultList <- cbind(resultList, m[,i])
return(resultList)
}
}
return(resultList)
}
help <- selectFeatures(nir.data[,4:ncol(nir.data)])
ncol(help)
ncol(nir.data)
source('~/Documents/UniSS19/statVerfahrenProjekt/main.R', echo=TRUE)
library(leaps)
nir.data <- read.csv("NIR.csv", sep = ";", header=TRUE)
head(nir.data)
ncol(nir.data)
#nir.model <- regsubsets(y=nir.data[,2], x=nir.data[,4:ncol(nir.data)], really.big = TRUE)
selectFeatures <- function(m){ #m matrix mit allein einflussgroessen
resultList <- matrix(nrow=nrow(m), ncol=0)
for(i in seq(1, ncol(m), 2)){ # Spaltenindex
print(i)
difference <- abs(sum((m[i] - m[i+1])) / nrow(m))
print(difference)
if(difference >= 0.001){
resultList <- cbind(resultList, m[,i:i+1])
}
else{
resultList <- cbind(resultList, m[,i])
}
if (i >= ncol(m)) {
resultList <- cbind(resultList, m[,i])
return(resultList)
}
}
return(resultList)
}
help <- selectFeatures(nir.data[,4:ncol(nir.data)])
ncol(help)
seq(1, ncol(m), 2)
seq(1, ncol(nir.data[,4:ncol(nir.data)]), 2)
ncol(nir.data)
library(leaps)
nir.data <- read.csv("NIR.csv", sep = ";", header=TRUE)
head(nir.data)
ncol(nir.data)
#nir.model <- regsubsets(y=nir.data[,2], x=nir.data[,4:ncol(nir.data)], really.big = TRUE)
selectFeatures <- function(m){ #m matrix mit allein einflussgroessen
resultList <- matrix(nrow=nrow(m), ncol=0)
for(i in seq(1, ncol(m), 2)){ # Spaltenindex
print(i)
if (i >= ncol(m)) {
resultList <- cbind(resultList, m[,i])
return(resultList)
}
difference <- abs(sum((m[i] - m[i+1])) / nrow(m))
print(difference)
if(difference >= 0.001){
resultList <- cbind(resultList, m[,i:i+1])
}
else{
resultList <- cbind(resultList, m[,i])
}
}
return(resultList)
}
help <- selectFeatures(nir.data[,4:ncol(nir.data)])
ncol(help)
library(leaps)
nir.data <- read.csv("NIR.csv", sep = ";", header=TRUE)
head(nir.data)
ncol(nir.data)
#nir.model <- regsubsets(y=nir.data[,2], x=nir.data[,4:ncol(nir.data)], really.big = TRUE)
selectFeatures <- function(m){ #m matrix mit allein einflussgroessen
resultList <- matrix(nrow=nrow(m), ncol=0)
for(i in seq(1, ncol(m), 2)){ # Spaltenindex
print(i)
if (i >= ncol(m)) {
resultList <- cbind(resultList, m[,i])
return(resultList)
}
difference <- abs(sum((m[i] - m[i+1])) / nrow(m))
print(difference)
if(difference > 0.001){
resultList <- cbind(resultList, m[,i:i+1])
}
else{
resultList <- cbind(resultList, m[,i])
}
}
return(resultList)
}
help <- selectFeatures(nir.data[,4:ncol(nir.data)])
ncol(help)
